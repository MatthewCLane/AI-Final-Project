# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TestInterface.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
#
# Authors:  Matthew Lane, Brandon Strong
# Network Generation: Brandon Strong, Cameron Goldberg, Matthew Lane, Troy Cudzilo
#

import os; os.system('')
import numpy as np
import cv2.cv2
from keras.models import load_model
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap
import timm
import torch
from torch import nn
from torch.utils.data import DataLoader
from torchvision import transforms as T, datasets
from numpy import exp


def softmax(vector):
    e = exp(vector)
    return e / e.sum()

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(679, 561)
        self.ProgramFrame = QtWidgets.QFrame(Dialog)
        self.ProgramFrame.setGeometry(QtCore.QRect(0, 0, 681, 561))
        self.ProgramFrame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.ProgramFrame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.ProgramFrame.setObjectName("ProgramFrame")
        self.groupBox = QtWidgets.QGroupBox(self.ProgramFrame)
        self.groupBox.setGeometry(QtCore.QRect(250, 480, 181, 71))
        self.groupBox.setTitle("")
        self.groupBox.setObjectName("groupBox")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.groupBox)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.pushButton_2 = QtWidgets.QPushButton(self.groupBox)
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(self.getfile)               
        self.gridLayout_2.addWidget(self.pushButton_2, 0, 0, 1, 1)
        self.ImageFrame = QtWidgets.QFrame(self.ProgramFrame)
        self.ImageFrame.setGeometry(QtCore.QRect(10, 40, 401, 421))
        self.ImageFrame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.ImageFrame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.ImageFrame.setObjectName("ImageFrame")
        self.XrayImage = QtWidgets.QGraphicsView(self.ImageFrame)
        self.XrayImage.setGeometry(QtCore.QRect(10, 10, 381, 401))
        self.XrayImage.setObjectName("XrayImage")

        #X-Ray Image Panel Initial Image
        #Create the scene for the X-Ray Image
        self.scene = QtWidgets.QGraphicsScene(self.XrayImage)
        #We want the the inital bacground to be a light gray to indicate that it's off.
        self.scene.setBackgroundBrush(QtGui.QBrush(QtCore.Qt.lightGray, QtCore.Qt.SolidPattern))
        #Create a pixmap, scale it, and add it to the scene.
        #By Stillwaterising - Own work, CC0, https://commons.wikimedia.org/w/index.php?curid=9686540
        self.pixmap = QPixmap("Chest_Xray_PA_3-8-2010.png")
        #Scale image to fit within panel
        self.pixmap = self.pixmap.scaled(379, 399, QtCore.Qt.KeepAspectRatio)
        self.item = QtWidgets.QGraphicsPixmapItem(self.pixmap)
        # Since this is the initial run, let's gray out the image, like the X-Ray film viewer isn't turned on
        self.effect = QtWidgets.QGraphicsColorizeEffect(self.scene)
        self.effect.setStrength(0.75)
        self.effect.setColor(QtGui.QColor('white'))
        self.item.setGraphicsEffect(self.effect)
        #Finally add item to scene.
        self.scene.addItem(self.item)
        # Center the image in the scene
        self.item.setTransformOriginPoint(self.item.boundingRect().center())
        self.XrayImage.setScene(self.scene)
        self.XrayImage.setCacheMode(QtWidgets.QGraphicsView.CacheBackground)
        self.ResultFrame = QtWidgets.QFrame(self.ProgramFrame)
        self.ResultFrame.setGeometry(QtCore.QRect(420, 40, 251, 421))
        self.ResultFrame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.ResultFrame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.ResultFrame.setObjectName("ResultFrame")
        self.ResultText = QtWidgets.QTextBrowser(self.ResultFrame)
        self.ResultText.setGeometry(QtCore.QRect(10, 60, 231, 351))
        self.ResultText.setObjectName("ResultText")
        self.ResultText.setText(
            "<p>" + "<strong>" + "Predicted: " + "</strong>" + "</p>"+ "<br>" + "<p>" + "<strong>"
            + " Certainty: " + "</strong>" + "</p>" + "<br" + "<p>" +"<h2>" + "Please Load X-ray" +"</h2>" )
        self.label = QtWidgets.QLabel(self.ResultFrame)
        self.label.setGeometry(QtCore.QRect(100, 20, 55, 16))
        self.label.setObjectName("label")
        self.comboBox = QtWidgets.QComboBox(self.ProgramFrame)
        self.comboBox.setGeometry(QtCore.QRect(510, 10, 161, 22))
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.pushButton_2.setText(_translate("Dialog", "Load X-ray"))
        self.label.setText(_translate("Dialog", "Result"))
        self.comboBox.setItemText(0, _translate("Dialog", "Trinary - TF"))
        self.comboBox.setItemText(1, _translate("Dialog", "Trinary - PyT"))
        self.comboBox.setItemText(2, _translate("Dialog", "Trinary, LowFN - TF"))
        self.comboBox.setItemText(3, _translate("Dialog", "Binary - TF"))
        self.comboBox.setItemText(4, _translate("Dialog", "Binary - PyT"))
        self.comboBox.setItemText(5, _translate("Dialog", "BinaryB+V - TF"))
        self.comboBox.setItemText(6, _translate("Dialog", "BinaryB+V - PyT"))
        self.comboBox.setItemText(7, _translate("Dialog", "BinaryB+V, LowFN - TF"))
        self.comboBox.currentTextChanged.connect(self.changeMethod)

        self.networktype = str(self.comboBox.currentText())

    def changeMethod(self):
        self.networktype = str(self.comboBox.currentText())

    def getfile(self):
        fname = QtWidgets.QFileDialog.getOpenFileName(None, 'Open file', os.getcwd(), 'Images(*.png *.gif *.jpg, *.jpeg)')
        #Since this is the first/subsequent runs, set background to white.
        self.scene.setBackgroundBrush(QtGui.QBrush(QtCore.Qt.white, QtCore.Qt.SolidPattern))
        #Paint the pixmap white and re-add it to the scene/panel
        self.pixmap.fill(QtCore.Qt.white)
        self.item = QtWidgets.QGraphicsPixmapItem(self.pixmap)
        # Finally add item to scene.
        self.scene.addItem(self.item)
        #Reset the result fields
        self.ResultText.setText(
            "<p>" + "<strong>" + "Predicted: " + "</strong>" + "</p>" + "<br>" + "<p>" + "<strong>"
            + " Certainty: " + "</strong>" + "</p>" + "<br" + "<p>" + "<h2 style=color:red;>" + "Please Load X-ray" + "</h2>")
        #Now that we have a blank slate, request image from the user.
        self.pixmap = QPixmap(fname[0])
        #Check that a file was loaded, load blank if not.
        if fname[0] != '':
            self.pixmap = self.pixmap.scaled(379, 399, QtCore.Qt.KeepAspectRatio)
            self.item = QtWidgets.QGraphicsPixmapItem(self.pixmap)
            # Finally add item to scene.
            self.scene.addItem(self.item)
        # Center the image in the scene
        self.item.setTransformOriginPoint(self.item.boundingRect().center())
        self.XrayImage.setScene(self.scene)
        self.XrayImage.setCacheMode(QtWidgets.QGraphicsView.CacheBackground)
        if fname[0] != '':
            # Display waiting message
            # This may take some time so present "Please Wait" message.
            self.ResultText.setText(
                "<p>" + "<strong>" + "Predicted: " + "</strong>" + "</p>" + "<br>" + "<p>" + "<strong>" + " Certainty: " + "</strong>" + "</p>" + "<br" + "<p>" + "<h2 style=color:blue;>" + "Please Wait..." + "</h2>")
            self.ResultText.repaint()

            if self.networktype == "Trinary - PyT" or self.networktype == "Binary - PyT" or self.networktype == "BinaryB+V - PyT":
                self.runPyTCNN(fname[0], 225, 225)
            elif self.networktype == "Trinary - TF" or self.networktype == "Binary - TF" or self.networktype == "BinaryB+V - TF":
                self.runCNN(fname[0], 100, 100)
            elif self.networktype == "BinaryB+V, LowFN - TF" or self.networktype =="Trinary, LowFN - TF":
                self.runCNN(fname[0], 200, 200)

    def runCNN(self, fname, width, height):
        #
        # This is where we will send the image through the CNN.
        # All we have to do here is do the same thing to the images that
        # We did in the OG project. Then load in the model, and use the predict function.
        #

        # Define an array
        imgArray = []

        # Read the image in using opencv
        modelImg = cv2.cv2.imread(fname)

        # Resize the image to be widthxheight
        modelImg = cv2.cv2.resize(modelImg, dsize=(width, height))

        # Convert the image into gray scale
        modelImg = cv2.cv2.cvtColor(modelImg, cv2.cv2.COLOR_BGR2GRAY)

        # Append the image to the array
        imgArray.append(modelImg)

        # Convert the array to a numpy array
        imgArray = np.array(imgArray)


        # Load in the model
        if self.networktype == "Trinary - TF":
            # These are the options that the AI will choose from
            options = ['Bacteria Pneumonia', 'Normal', 'Virus Pneumonia']

            # Load the model
            model = load_model('adamaxE12085.09_100x100_L1N150L2N610_12_14K18K27P18P29_105.h5')
        elif self.networktype == "Binary - TF":
            # These are the options that the AI will choose from
            options = ['Normal', 'Pneumonia']

            # Load the model
            model = load_model('binary_model_tf.h5')

        elif self.networktype == "BinaryB+V - TF":
            # These are the options that the AI will choose from
            options = ['Pneumonia', 'Normal', 'Pneumonia']

            # Load the model
            model = load_model('adamaxE12085.09_100x100_L1N150L2N610_F1_12F2_14K1_8K2_7P1_8P2_9_32.h5')

        elif self.networktype == 'BinaryB+V, LowFN - TF':
            # These are the options that the AI will choose from
            options = ['Pneumonia', 'Normal', 'Pneumonia']

            # Load the model
            model = load_model('adamE12085.09L1N150L2N610_12 21K3,2str(poolsize).h5')

        elif self.networktype == 'Trinary, LowFN - TF':
            # These are the options that the AI will choose from
            options = ['Bacteria Pneumonia', 'Normal', 'Virus Pneumonia']

            # Load the model
            model = load_model('adamE12085.09L1N150L2N610_12 21K3,2str(poolsize).h5')

        # Send the image into the CNN. Will return an array of 3 numpyFloats.
        # Highest number is what the AI predicts. (Links directly up with the options)
        prediction = model.predict(imgArray)

        #
        # Find the biggest number in prediction, and get that numbers index
        #
        index = 0
        iteration = 0
        biggest = np.float32(0)
        for i in prediction:
            for l in i:
                if l > biggest:
                    biggest = l
                    index = iteration
                iteration += 1

        # Now that we know what the highest numbers index is, we can use that in our options array to get
        # The text that our AI predicts. (Creates the Label)
        #   options[index]
        #And the percentage
        #   prediction[0][index]

        # Add these to the GUi
        self.displayresult(options[index], prediction[0][index])


    def displayresult(self, result, percentage):
        self.ResultText.setText("<p>" + "<strong>" + "Predicted: " + "</strong>" + "</p>" + result + "<br>" + "<p>" + "<strong>" + " Certainty: " + "</strong>" + "</p>" + str(round((percentage*100), 2)) + '%')

    def runPyTCNN(self, fname, width, height):

        # Having the options of what the AI can choose from
        class_names = ['Bacteria Pneumonia', 'Normal', 'Virus Pneumonia']

        # Decide if we are using our GPU or CPU to calculate
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        # Set the model name
        model_name = 'tf_efficientnet_b4_ns'

        # Create the model
        model = timm.create_model(model_name, pretrained=True)


        # Set parameters to False
        for param in model.parameters():
            param.requires_grad = False

        # Set up the sturcture for the NN
        model.classifier = nn.Sequential(

            nn.Linear(in_features=1792, out_features=625),
            nn.ReLU(),
            nn.Dropout(p=0.3),
            nn.Linear(in_features=625, out_features=256),
            nn.ReLU(),
            nn.Linear(in_features=256, out_features=3)
        )
        # Use CPU or GPU for the NN
        model.to(device)

        # We aren't training so we will be evaluating the model
        model.eval()

        # Load in the model
        if self.networktype == "Trinary - PyT":
            model.load_state_dict(torch.load('ColabPneumoniaModel_120E.pt'))
        elif self.networktype == "Binary - PyT":
            class_names = ['Normal', 'Pneumonia']
            model.load_state_dict(torch.load('ColabPneumoniaModel_120E_Binary.pt'))
        elif self.networktype == "BinaryB+V - PyT":
            class_names = ['Pneumonia', 'Normal', 'Pneumonia']
            model.load_state_dict(torch.load('ColabPneumoniaModel_120E.pt'))

        # Settings to make to the images
        imageTransform = T.Compose([
            #Resize image to width, height
            T.Resize(size=(width, height)),
            T.ToTensor(),
            T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])

        # Declaring vars
        fileName = ''
        num = 0
        found = 0
        folderName = ''

        #
        # Because of the functions that we need to use to load in an image we
        # need to find the file that we have loaded in the file system...
        # Without using the full file path...
        #

        #
        # Get the name of the file, and the folder name
        #

        # Reverse the filepath string so we can get the information that we need
        for i in reversed(fname):
            num += 1

            # If we find a '/' then we can start adding the folder name
            if i == '/':
                found += 1
            # Add filename right away until '/' is found
            if found == 0:
                fileName = fileName + i

            elif found == 1:
                folderName = folderName + i
            # We don't have anything else we need from the string. End loop
            else:
                break

        # Reverse the string again to get it in it's correct orientation
        tmp = reversed(fileName)
        tmp2 = ''
        for i in tmp:
            tmp2 = tmp2 + i
        fileName = tmp2

        tmp = reversed(folderName)
        tmp2 = ''
        for i in tmp:
            tmp2 = tmp2 + i
        folderName = tmp2

        # We don't want the folder and filename added to the path for the next function
        fname = fname[0:len(fname)-num]

        # Get all of the files in the directory (Through all of the folders)
        allImages = datasets.ImageFolder(fname, transform=imageTransform)

        # Get a list of all the folders and files in the directory
        listOfFolders = os.walk(fname)

        # Get just the folder name. Turns out we don't need the '/'.
        # We can't match the path in listOfFolders otherwise.
        justFolderName = folderName[0 : len(folderName)-1]

        indexOfFolder = 0

        # We have our folder name for the image... Loop through the listOfFolders
        # to match the two directories. Get that index number for the array.
        # That is where the folder we will have to access.
        for i in listOfFolders:

            if i[0] == fname + '\\' + justFolderName:
                # This is where all the images are located
                allImagesInDir = i[2]
                # End loop we have found what we need
                break
            indexOfFolder += 1

        # Find the index of where the image is in the list
        arrayIndex = 0
        for i in allImagesInDir:
            # If we find the file then stop the loop
            if i == fileName:
                break
            arrayIndex += 1

        #print('allimages: ', allImages[arrayIndex])
        # We now know what image to load in. because we have found the index of where it is in the folder
        testImageData = DataLoader(allImages[arrayIndex], shuffle=False)

        # Load the image into the testImage list (Raw data) and a folder identifier
        testImage = []
        for i in testImageData:
            testImage.append(i)

        # Set the device to process the image (CPU or GPU)
        imageToTest = testImage[0].to(device)

        # Make the prediction. Returns tensors
        prediction = model(imageToTest)

        # Put all of the predictions into a vector so they can be fed into the softmax function
        # The values will not be between 0 and 1 otherwise
        predictionVector = []
        for i in prediction.cpu().detach().numpy()[0]:
            predictionVector.append(i)

        # Get the softmax values for the prediction
        certainty = softmax(predictionVector)

        # Get the index of the number that has the highest prediction
        index = np.argmax(np.array(certainty))

        # Display the guessed class, and the certainty of the prediction
        self.displayresult(class_names[index], max(certainty))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    app.setStyleSheet("QTextBrowser { font-size: 12pt}" "QLabel, QPushButton {font-size: 12pt; font-weight: bold}")
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())